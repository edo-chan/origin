// Code generated by protoc-gen-ts_proto. DO NOT EDIT.
// versions:
//   protoc-gen-ts_proto  v2.7.5
//   protoc               v5.29.3
// source: auth.proto

/* eslint-disable */
import { BinaryReader, BinaryWriter } from "@bufbuild/protobuf/wire";

export const protobufPackage = "auth";

/** Request to initiate OAuth flow */
export interface InitiateOAuthRequest {
  /** Optional custom redirect URI */
  redirectUri?:
    | string
    | undefined;
  /** Device identification */
  deviceName?: string | undefined;
}

/** Response with OAuth authorization URL */
export interface InitiateOAuthResponse {
  /** Google OAuth authorization URL */
  authUrl: string;
  /** State token for CSRF protection */
  stateToken: string;
  /** State expiration timestamp */
  expiresAt: bigint;
}

/** Request to complete OAuth flow */
export interface CompleteOAuthRequest {
  /** Authorization code from Google */
  code: string;
  /** State parameter for CSRF validation */
  state: string;
  /** JSON string with device information */
  deviceInfo?:
    | string
    | undefined;
  /** Client IP address */
  ipAddress?:
    | string
    | undefined;
  /** User agent string */
  userAgent?: string | undefined;
}

/** Response with JWT tokens */
export interface CompleteOAuthResponse {
  /** JWT access token */
  accessToken: string;
  /** JWT refresh token */
  refreshToken: string;
  /** Access token expiration */
  accessTokenExpiresAt: bigint;
  /** Refresh token expiration */
  refreshTokenExpiresAt: bigint;
  /** "Bearer" */
  tokenType: string;
  /** User profile information */
  user:
    | UserProfile
    | undefined;
  /** Whether this is a newly created user */
  isNewUser: boolean;
}

/** Request to refresh access token */
export interface RefreshTokenRequest {
  /** Current refresh token */
  refreshToken: string;
}

/** Response with new access token */
export interface RefreshTokenResponse {
  /** New JWT access token */
  accessToken: string;
  /** New access token expiration */
  accessTokenExpiresAt: bigint;
  /** "Bearer" */
  tokenType: string;
}

/** Request to logout */
export interface LogoutRequest {
  /** Current access token */
  accessToken: string;
}

/** Response for logout */
export interface LogoutResponse {
  /** Whether logout was successful */
  success: boolean;
  /** Success/error message */
  message: string;
}

/** Request to logout from all devices */
export interface LogoutAllRequest {
  /** Current access token */
  accessToken: string;
}

/** Response for logout all */
export interface LogoutAllResponse {
  /** Whether logout was successful */
  success: boolean;
  /** Number of sessions revoked */
  revokedSessions: number;
  /** Success/error message */
  message: string;
}

/** Request to validate token */
export interface ValidateTokenRequest {
  /** Access token to validate */
  accessToken: string;
}

/** Response with token validation result */
export interface ValidateTokenResponse {
  /** Whether token is valid */
  valid: boolean;
  /** User profile if valid */
  user:
    | UserProfile
    | undefined;
  /** Session ID if valid */
  sessionId: string;
  /** Token expiration if valid */
  expiresAt: bigint;
}

/** Request to get user profile */
export interface GetProfileRequest {
  /** Access token */
  accessToken: string;
}

/** Response with user profile */
export interface GetProfileResponse {
  /** User profile information */
  user: UserProfile | undefined;
}

/** Request to get user sessions */
export interface GetUserSessionsRequest {
  /** Access token */
  accessToken: string;
}

/** Response with user sessions */
export interface GetUserSessionsResponse {
  /** List of active sessions */
  sessions: UserSession[];
}

/** Request to revoke a specific session */
export interface RevokeSessionRequest {
  /** Access token */
  accessToken: string;
  /** Session ID to revoke */
  sessionId: string;
  /** Reason for revocation */
  reason?: string | undefined;
}

/** Response for session revocation */
export interface RevokeSessionResponse {
  /** Whether revocation was successful */
  success: boolean;
  /** Success/error message */
  message: string;
}

/** User profile information */
export interface UserProfile {
  /** User UUID */
  id: string;
  /** Google OAuth ID */
  googleId: string;
  /** User email */
  email: string;
  /** Display name */
  name: string;
  /** First name */
  givenName?:
    | string
    | undefined;
  /** Last name */
  familyName?:
    | string
    | undefined;
  /** Profile picture URL */
  pictureUrl?:
    | string
    | undefined;
  /** User locale */
  locale?:
    | string
    | undefined;
  /** Whether account is active */
  isActive: boolean;
  /** Whether account is verified */
  isVerified: boolean;
  /** Account creation timestamp (Unix timestamp) */
  createdAt: bigint;
  /** Last update timestamp (Unix timestamp) */
  updatedAt: bigint;
  /** Last login timestamp (Unix timestamp) */
  lastLoginAt?:
    | bigint
    | undefined;
  /** JSON string with user preferences */
  preferences: string;
}

/** User session information */
export interface UserSession {
  /** Session UUID */
  id: string;
  /** JSON string with device information */
  deviceInfo: string;
  /** IP address */
  ipAddress?:
    | string
    | undefined;
  /** User agent string */
  userAgent?:
    | string
    | undefined;
  /** Session creation timestamp (Unix timestamp) */
  createdAt: bigint;
  /** Last activity timestamp (Unix timestamp) */
  lastActivityAt: bigint;
  /** Session expiration timestamp (Unix timestamp) */
  expiresAt: bigint;
  /** Whether this is the current session */
  isCurrent: boolean;
}

function createBaseInitiateOAuthRequest(): InitiateOAuthRequest {
  return { redirectUri: undefined, deviceName: undefined };
}

export const InitiateOAuthRequest: MessageFns<InitiateOAuthRequest> = {
  encode(message: InitiateOAuthRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.redirectUri !== undefined) {
      writer.uint32(10).string(message.redirectUri);
    }
    if (message.deviceName !== undefined) {
      writer.uint32(18).string(message.deviceName);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): InitiateOAuthRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseInitiateOAuthRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.redirectUri = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.deviceName = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): InitiateOAuthRequest {
    return {
      redirectUri: isSet(object.redirectUri) ? globalThis.String(object.redirectUri) : undefined,
      deviceName: isSet(object.deviceName) ? globalThis.String(object.deviceName) : undefined,
    };
  },

  toJSON(message: InitiateOAuthRequest): unknown {
    const obj: any = {};
    if (message.redirectUri !== undefined) {
      obj.redirectUri = message.redirectUri;
    }
    if (message.deviceName !== undefined) {
      obj.deviceName = message.deviceName;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<InitiateOAuthRequest>, I>>(base?: I): InitiateOAuthRequest {
    return InitiateOAuthRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<InitiateOAuthRequest>, I>>(object: I): InitiateOAuthRequest {
    const message = createBaseInitiateOAuthRequest();
    message.redirectUri = object.redirectUri ?? undefined;
    message.deviceName = object.deviceName ?? undefined;
    return message;
  },
};

function createBaseInitiateOAuthResponse(): InitiateOAuthResponse {
  return { authUrl: "", stateToken: "", expiresAt: 0n };
}

export const InitiateOAuthResponse: MessageFns<InitiateOAuthResponse> = {
  encode(message: InitiateOAuthResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.authUrl !== "") {
      writer.uint32(10).string(message.authUrl);
    }
    if (message.stateToken !== "") {
      writer.uint32(18).string(message.stateToken);
    }
    if (message.expiresAt !== 0n) {
      if (BigInt.asIntN(64, message.expiresAt) !== message.expiresAt) {
        throw new globalThis.Error("value provided for field message.expiresAt of type int64 too large");
      }
      writer.uint32(24).int64(message.expiresAt);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): InitiateOAuthResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseInitiateOAuthResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.authUrl = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.stateToken = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 24) {
            break;
          }

          message.expiresAt = reader.int64() as bigint;
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): InitiateOAuthResponse {
    return {
      authUrl: isSet(object.authUrl) ? globalThis.String(object.authUrl) : "",
      stateToken: isSet(object.stateToken) ? globalThis.String(object.stateToken) : "",
      expiresAt: isSet(object.expiresAt) ? BigInt(object.expiresAt) : 0n,
    };
  },

  toJSON(message: InitiateOAuthResponse): unknown {
    const obj: any = {};
    if (message.authUrl !== "") {
      obj.authUrl = message.authUrl;
    }
    if (message.stateToken !== "") {
      obj.stateToken = message.stateToken;
    }
    if (message.expiresAt !== 0n) {
      obj.expiresAt = message.expiresAt.toString();
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<InitiateOAuthResponse>, I>>(base?: I): InitiateOAuthResponse {
    return InitiateOAuthResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<InitiateOAuthResponse>, I>>(object: I): InitiateOAuthResponse {
    const message = createBaseInitiateOAuthResponse();
    message.authUrl = object.authUrl ?? "";
    message.stateToken = object.stateToken ?? "";
    message.expiresAt = object.expiresAt ?? 0n;
    return message;
  },
};

function createBaseCompleteOAuthRequest(): CompleteOAuthRequest {
  return { code: "", state: "", deviceInfo: undefined, ipAddress: undefined, userAgent: undefined };
}

export const CompleteOAuthRequest: MessageFns<CompleteOAuthRequest> = {
  encode(message: CompleteOAuthRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.code !== "") {
      writer.uint32(10).string(message.code);
    }
    if (message.state !== "") {
      writer.uint32(18).string(message.state);
    }
    if (message.deviceInfo !== undefined) {
      writer.uint32(26).string(message.deviceInfo);
    }
    if (message.ipAddress !== undefined) {
      writer.uint32(34).string(message.ipAddress);
    }
    if (message.userAgent !== undefined) {
      writer.uint32(42).string(message.userAgent);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): CompleteOAuthRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCompleteOAuthRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.code = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.state = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.deviceInfo = reader.string();
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.ipAddress = reader.string();
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.userAgent = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CompleteOAuthRequest {
    return {
      code: isSet(object.code) ? globalThis.String(object.code) : "",
      state: isSet(object.state) ? globalThis.String(object.state) : "",
      deviceInfo: isSet(object.deviceInfo) ? globalThis.String(object.deviceInfo) : undefined,
      ipAddress: isSet(object.ipAddress) ? globalThis.String(object.ipAddress) : undefined,
      userAgent: isSet(object.userAgent) ? globalThis.String(object.userAgent) : undefined,
    };
  },

  toJSON(message: CompleteOAuthRequest): unknown {
    const obj: any = {};
    if (message.code !== "") {
      obj.code = message.code;
    }
    if (message.state !== "") {
      obj.state = message.state;
    }
    if (message.deviceInfo !== undefined) {
      obj.deviceInfo = message.deviceInfo;
    }
    if (message.ipAddress !== undefined) {
      obj.ipAddress = message.ipAddress;
    }
    if (message.userAgent !== undefined) {
      obj.userAgent = message.userAgent;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<CompleteOAuthRequest>, I>>(base?: I): CompleteOAuthRequest {
    return CompleteOAuthRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<CompleteOAuthRequest>, I>>(object: I): CompleteOAuthRequest {
    const message = createBaseCompleteOAuthRequest();
    message.code = object.code ?? "";
    message.state = object.state ?? "";
    message.deviceInfo = object.deviceInfo ?? undefined;
    message.ipAddress = object.ipAddress ?? undefined;
    message.userAgent = object.userAgent ?? undefined;
    return message;
  },
};

function createBaseCompleteOAuthResponse(): CompleteOAuthResponse {
  return {
    accessToken: "",
    refreshToken: "",
    accessTokenExpiresAt: 0n,
    refreshTokenExpiresAt: 0n,
    tokenType: "",
    user: undefined,
    isNewUser: false,
  };
}

export const CompleteOAuthResponse: MessageFns<CompleteOAuthResponse> = {
  encode(message: CompleteOAuthResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.accessToken !== "") {
      writer.uint32(10).string(message.accessToken);
    }
    if (message.refreshToken !== "") {
      writer.uint32(18).string(message.refreshToken);
    }
    if (message.accessTokenExpiresAt !== 0n) {
      if (BigInt.asIntN(64, message.accessTokenExpiresAt) !== message.accessTokenExpiresAt) {
        throw new globalThis.Error("value provided for field message.accessTokenExpiresAt of type int64 too large");
      }
      writer.uint32(24).int64(message.accessTokenExpiresAt);
    }
    if (message.refreshTokenExpiresAt !== 0n) {
      if (BigInt.asIntN(64, message.refreshTokenExpiresAt) !== message.refreshTokenExpiresAt) {
        throw new globalThis.Error("value provided for field message.refreshTokenExpiresAt of type int64 too large");
      }
      writer.uint32(32).int64(message.refreshTokenExpiresAt);
    }
    if (message.tokenType !== "") {
      writer.uint32(42).string(message.tokenType);
    }
    if (message.user !== undefined) {
      UserProfile.encode(message.user, writer.uint32(50).fork()).join();
    }
    if (message.isNewUser !== false) {
      writer.uint32(56).bool(message.isNewUser);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): CompleteOAuthResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCompleteOAuthResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.accessToken = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.refreshToken = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 24) {
            break;
          }

          message.accessTokenExpiresAt = reader.int64() as bigint;
          continue;
        }
        case 4: {
          if (tag !== 32) {
            break;
          }

          message.refreshTokenExpiresAt = reader.int64() as bigint;
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.tokenType = reader.string();
          continue;
        }
        case 6: {
          if (tag !== 50) {
            break;
          }

          message.user = UserProfile.decode(reader, reader.uint32());
          continue;
        }
        case 7: {
          if (tag !== 56) {
            break;
          }

          message.isNewUser = reader.bool();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CompleteOAuthResponse {
    return {
      accessToken: isSet(object.accessToken) ? globalThis.String(object.accessToken) : "",
      refreshToken: isSet(object.refreshToken) ? globalThis.String(object.refreshToken) : "",
      accessTokenExpiresAt: isSet(object.accessTokenExpiresAt) ? BigInt(object.accessTokenExpiresAt) : 0n,
      refreshTokenExpiresAt: isSet(object.refreshTokenExpiresAt) ? BigInt(object.refreshTokenExpiresAt) : 0n,
      tokenType: isSet(object.tokenType) ? globalThis.String(object.tokenType) : "",
      user: isSet(object.user) ? UserProfile.fromJSON(object.user) : undefined,
      isNewUser: isSet(object.isNewUser) ? globalThis.Boolean(object.isNewUser) : false,
    };
  },

  toJSON(message: CompleteOAuthResponse): unknown {
    const obj: any = {};
    if (message.accessToken !== "") {
      obj.accessToken = message.accessToken;
    }
    if (message.refreshToken !== "") {
      obj.refreshToken = message.refreshToken;
    }
    if (message.accessTokenExpiresAt !== 0n) {
      obj.accessTokenExpiresAt = message.accessTokenExpiresAt.toString();
    }
    if (message.refreshTokenExpiresAt !== 0n) {
      obj.refreshTokenExpiresAt = message.refreshTokenExpiresAt.toString();
    }
    if (message.tokenType !== "") {
      obj.tokenType = message.tokenType;
    }
    if (message.user !== undefined) {
      obj.user = UserProfile.toJSON(message.user);
    }
    if (message.isNewUser !== false) {
      obj.isNewUser = message.isNewUser;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<CompleteOAuthResponse>, I>>(base?: I): CompleteOAuthResponse {
    return CompleteOAuthResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<CompleteOAuthResponse>, I>>(object: I): CompleteOAuthResponse {
    const message = createBaseCompleteOAuthResponse();
    message.accessToken = object.accessToken ?? "";
    message.refreshToken = object.refreshToken ?? "";
    message.accessTokenExpiresAt = object.accessTokenExpiresAt ?? 0n;
    message.refreshTokenExpiresAt = object.refreshTokenExpiresAt ?? 0n;
    message.tokenType = object.tokenType ?? "";
    message.user = (object.user !== undefined && object.user !== null)
      ? UserProfile.fromPartial(object.user)
      : undefined;
    message.isNewUser = object.isNewUser ?? false;
    return message;
  },
};

function createBaseRefreshTokenRequest(): RefreshTokenRequest {
  return { refreshToken: "" };
}

export const RefreshTokenRequest: MessageFns<RefreshTokenRequest> = {
  encode(message: RefreshTokenRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.refreshToken !== "") {
      writer.uint32(10).string(message.refreshToken);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): RefreshTokenRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseRefreshTokenRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.refreshToken = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): RefreshTokenRequest {
    return { refreshToken: isSet(object.refreshToken) ? globalThis.String(object.refreshToken) : "" };
  },

  toJSON(message: RefreshTokenRequest): unknown {
    const obj: any = {};
    if (message.refreshToken !== "") {
      obj.refreshToken = message.refreshToken;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<RefreshTokenRequest>, I>>(base?: I): RefreshTokenRequest {
    return RefreshTokenRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<RefreshTokenRequest>, I>>(object: I): RefreshTokenRequest {
    const message = createBaseRefreshTokenRequest();
    message.refreshToken = object.refreshToken ?? "";
    return message;
  },
};

function createBaseRefreshTokenResponse(): RefreshTokenResponse {
  return { accessToken: "", accessTokenExpiresAt: 0n, tokenType: "" };
}

export const RefreshTokenResponse: MessageFns<RefreshTokenResponse> = {
  encode(message: RefreshTokenResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.accessToken !== "") {
      writer.uint32(10).string(message.accessToken);
    }
    if (message.accessTokenExpiresAt !== 0n) {
      if (BigInt.asIntN(64, message.accessTokenExpiresAt) !== message.accessTokenExpiresAt) {
        throw new globalThis.Error("value provided for field message.accessTokenExpiresAt of type int64 too large");
      }
      writer.uint32(16).int64(message.accessTokenExpiresAt);
    }
    if (message.tokenType !== "") {
      writer.uint32(26).string(message.tokenType);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): RefreshTokenResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseRefreshTokenResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.accessToken = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.accessTokenExpiresAt = reader.int64() as bigint;
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.tokenType = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): RefreshTokenResponse {
    return {
      accessToken: isSet(object.accessToken) ? globalThis.String(object.accessToken) : "",
      accessTokenExpiresAt: isSet(object.accessTokenExpiresAt) ? BigInt(object.accessTokenExpiresAt) : 0n,
      tokenType: isSet(object.tokenType) ? globalThis.String(object.tokenType) : "",
    };
  },

  toJSON(message: RefreshTokenResponse): unknown {
    const obj: any = {};
    if (message.accessToken !== "") {
      obj.accessToken = message.accessToken;
    }
    if (message.accessTokenExpiresAt !== 0n) {
      obj.accessTokenExpiresAt = message.accessTokenExpiresAt.toString();
    }
    if (message.tokenType !== "") {
      obj.tokenType = message.tokenType;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<RefreshTokenResponse>, I>>(base?: I): RefreshTokenResponse {
    return RefreshTokenResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<RefreshTokenResponse>, I>>(object: I): RefreshTokenResponse {
    const message = createBaseRefreshTokenResponse();
    message.accessToken = object.accessToken ?? "";
    message.accessTokenExpiresAt = object.accessTokenExpiresAt ?? 0n;
    message.tokenType = object.tokenType ?? "";
    return message;
  },
};

function createBaseLogoutRequest(): LogoutRequest {
  return { accessToken: "" };
}

export const LogoutRequest: MessageFns<LogoutRequest> = {
  encode(message: LogoutRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.accessToken !== "") {
      writer.uint32(10).string(message.accessToken);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): LogoutRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseLogoutRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.accessToken = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): LogoutRequest {
    return { accessToken: isSet(object.accessToken) ? globalThis.String(object.accessToken) : "" };
  },

  toJSON(message: LogoutRequest): unknown {
    const obj: any = {};
    if (message.accessToken !== "") {
      obj.accessToken = message.accessToken;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<LogoutRequest>, I>>(base?: I): LogoutRequest {
    return LogoutRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<LogoutRequest>, I>>(object: I): LogoutRequest {
    const message = createBaseLogoutRequest();
    message.accessToken = object.accessToken ?? "";
    return message;
  },
};

function createBaseLogoutResponse(): LogoutResponse {
  return { success: false, message: "" };
}

export const LogoutResponse: MessageFns<LogoutResponse> = {
  encode(message: LogoutResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.success !== false) {
      writer.uint32(8).bool(message.success);
    }
    if (message.message !== "") {
      writer.uint32(18).string(message.message);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): LogoutResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseLogoutResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.success = reader.bool();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.message = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): LogoutResponse {
    return {
      success: isSet(object.success) ? globalThis.Boolean(object.success) : false,
      message: isSet(object.message) ? globalThis.String(object.message) : "",
    };
  },

  toJSON(message: LogoutResponse): unknown {
    const obj: any = {};
    if (message.success !== false) {
      obj.success = message.success;
    }
    if (message.message !== "") {
      obj.message = message.message;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<LogoutResponse>, I>>(base?: I): LogoutResponse {
    return LogoutResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<LogoutResponse>, I>>(object: I): LogoutResponse {
    const message = createBaseLogoutResponse();
    message.success = object.success ?? false;
    message.message = object.message ?? "";
    return message;
  },
};

function createBaseLogoutAllRequest(): LogoutAllRequest {
  return { accessToken: "" };
}

export const LogoutAllRequest: MessageFns<LogoutAllRequest> = {
  encode(message: LogoutAllRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.accessToken !== "") {
      writer.uint32(10).string(message.accessToken);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): LogoutAllRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseLogoutAllRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.accessToken = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): LogoutAllRequest {
    return { accessToken: isSet(object.accessToken) ? globalThis.String(object.accessToken) : "" };
  },

  toJSON(message: LogoutAllRequest): unknown {
    const obj: any = {};
    if (message.accessToken !== "") {
      obj.accessToken = message.accessToken;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<LogoutAllRequest>, I>>(base?: I): LogoutAllRequest {
    return LogoutAllRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<LogoutAllRequest>, I>>(object: I): LogoutAllRequest {
    const message = createBaseLogoutAllRequest();
    message.accessToken = object.accessToken ?? "";
    return message;
  },
};

function createBaseLogoutAllResponse(): LogoutAllResponse {
  return { success: false, revokedSessions: 0, message: "" };
}

export const LogoutAllResponse: MessageFns<LogoutAllResponse> = {
  encode(message: LogoutAllResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.success !== false) {
      writer.uint32(8).bool(message.success);
    }
    if (message.revokedSessions !== 0) {
      writer.uint32(16).int32(message.revokedSessions);
    }
    if (message.message !== "") {
      writer.uint32(26).string(message.message);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): LogoutAllResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseLogoutAllResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.success = reader.bool();
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.revokedSessions = reader.int32();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.message = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): LogoutAllResponse {
    return {
      success: isSet(object.success) ? globalThis.Boolean(object.success) : false,
      revokedSessions: isSet(object.revokedSessions) ? globalThis.Number(object.revokedSessions) : 0,
      message: isSet(object.message) ? globalThis.String(object.message) : "",
    };
  },

  toJSON(message: LogoutAllResponse): unknown {
    const obj: any = {};
    if (message.success !== false) {
      obj.success = message.success;
    }
    if (message.revokedSessions !== 0) {
      obj.revokedSessions = Math.round(message.revokedSessions);
    }
    if (message.message !== "") {
      obj.message = message.message;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<LogoutAllResponse>, I>>(base?: I): LogoutAllResponse {
    return LogoutAllResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<LogoutAllResponse>, I>>(object: I): LogoutAllResponse {
    const message = createBaseLogoutAllResponse();
    message.success = object.success ?? false;
    message.revokedSessions = object.revokedSessions ?? 0;
    message.message = object.message ?? "";
    return message;
  },
};

function createBaseValidateTokenRequest(): ValidateTokenRequest {
  return { accessToken: "" };
}

export const ValidateTokenRequest: MessageFns<ValidateTokenRequest> = {
  encode(message: ValidateTokenRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.accessToken !== "") {
      writer.uint32(10).string(message.accessToken);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ValidateTokenRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseValidateTokenRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.accessToken = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ValidateTokenRequest {
    return { accessToken: isSet(object.accessToken) ? globalThis.String(object.accessToken) : "" };
  },

  toJSON(message: ValidateTokenRequest): unknown {
    const obj: any = {};
    if (message.accessToken !== "") {
      obj.accessToken = message.accessToken;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<ValidateTokenRequest>, I>>(base?: I): ValidateTokenRequest {
    return ValidateTokenRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<ValidateTokenRequest>, I>>(object: I): ValidateTokenRequest {
    const message = createBaseValidateTokenRequest();
    message.accessToken = object.accessToken ?? "";
    return message;
  },
};

function createBaseValidateTokenResponse(): ValidateTokenResponse {
  return { valid: false, user: undefined, sessionId: "", expiresAt: 0n };
}

export const ValidateTokenResponse: MessageFns<ValidateTokenResponse> = {
  encode(message: ValidateTokenResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.valid !== false) {
      writer.uint32(8).bool(message.valid);
    }
    if (message.user !== undefined) {
      UserProfile.encode(message.user, writer.uint32(18).fork()).join();
    }
    if (message.sessionId !== "") {
      writer.uint32(26).string(message.sessionId);
    }
    if (message.expiresAt !== 0n) {
      if (BigInt.asIntN(64, message.expiresAt) !== message.expiresAt) {
        throw new globalThis.Error("value provided for field message.expiresAt of type int64 too large");
      }
      writer.uint32(32).int64(message.expiresAt);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ValidateTokenResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseValidateTokenResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.valid = reader.bool();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.user = UserProfile.decode(reader, reader.uint32());
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.sessionId = reader.string();
          continue;
        }
        case 4: {
          if (tag !== 32) {
            break;
          }

          message.expiresAt = reader.int64() as bigint;
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ValidateTokenResponse {
    return {
      valid: isSet(object.valid) ? globalThis.Boolean(object.valid) : false,
      user: isSet(object.user) ? UserProfile.fromJSON(object.user) : undefined,
      sessionId: isSet(object.sessionId) ? globalThis.String(object.sessionId) : "",
      expiresAt: isSet(object.expiresAt) ? BigInt(object.expiresAt) : 0n,
    };
  },

  toJSON(message: ValidateTokenResponse): unknown {
    const obj: any = {};
    if (message.valid !== false) {
      obj.valid = message.valid;
    }
    if (message.user !== undefined) {
      obj.user = UserProfile.toJSON(message.user);
    }
    if (message.sessionId !== "") {
      obj.sessionId = message.sessionId;
    }
    if (message.expiresAt !== 0n) {
      obj.expiresAt = message.expiresAt.toString();
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<ValidateTokenResponse>, I>>(base?: I): ValidateTokenResponse {
    return ValidateTokenResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<ValidateTokenResponse>, I>>(object: I): ValidateTokenResponse {
    const message = createBaseValidateTokenResponse();
    message.valid = object.valid ?? false;
    message.user = (object.user !== undefined && object.user !== null)
      ? UserProfile.fromPartial(object.user)
      : undefined;
    message.sessionId = object.sessionId ?? "";
    message.expiresAt = object.expiresAt ?? 0n;
    return message;
  },
};

function createBaseGetProfileRequest(): GetProfileRequest {
  return { accessToken: "" };
}

export const GetProfileRequest: MessageFns<GetProfileRequest> = {
  encode(message: GetProfileRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.accessToken !== "") {
      writer.uint32(10).string(message.accessToken);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): GetProfileRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetProfileRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.accessToken = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GetProfileRequest {
    return { accessToken: isSet(object.accessToken) ? globalThis.String(object.accessToken) : "" };
  },

  toJSON(message: GetProfileRequest): unknown {
    const obj: any = {};
    if (message.accessToken !== "") {
      obj.accessToken = message.accessToken;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<GetProfileRequest>, I>>(base?: I): GetProfileRequest {
    return GetProfileRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<GetProfileRequest>, I>>(object: I): GetProfileRequest {
    const message = createBaseGetProfileRequest();
    message.accessToken = object.accessToken ?? "";
    return message;
  },
};

function createBaseGetProfileResponse(): GetProfileResponse {
  return { user: undefined };
}

export const GetProfileResponse: MessageFns<GetProfileResponse> = {
  encode(message: GetProfileResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.user !== undefined) {
      UserProfile.encode(message.user, writer.uint32(10).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): GetProfileResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetProfileResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.user = UserProfile.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GetProfileResponse {
    return { user: isSet(object.user) ? UserProfile.fromJSON(object.user) : undefined };
  },

  toJSON(message: GetProfileResponse): unknown {
    const obj: any = {};
    if (message.user !== undefined) {
      obj.user = UserProfile.toJSON(message.user);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<GetProfileResponse>, I>>(base?: I): GetProfileResponse {
    return GetProfileResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<GetProfileResponse>, I>>(object: I): GetProfileResponse {
    const message = createBaseGetProfileResponse();
    message.user = (object.user !== undefined && object.user !== null)
      ? UserProfile.fromPartial(object.user)
      : undefined;
    return message;
  },
};

function createBaseGetUserSessionsRequest(): GetUserSessionsRequest {
  return { accessToken: "" };
}

export const GetUserSessionsRequest: MessageFns<GetUserSessionsRequest> = {
  encode(message: GetUserSessionsRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.accessToken !== "") {
      writer.uint32(10).string(message.accessToken);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): GetUserSessionsRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetUserSessionsRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.accessToken = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GetUserSessionsRequest {
    return { accessToken: isSet(object.accessToken) ? globalThis.String(object.accessToken) : "" };
  },

  toJSON(message: GetUserSessionsRequest): unknown {
    const obj: any = {};
    if (message.accessToken !== "") {
      obj.accessToken = message.accessToken;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<GetUserSessionsRequest>, I>>(base?: I): GetUserSessionsRequest {
    return GetUserSessionsRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<GetUserSessionsRequest>, I>>(object: I): GetUserSessionsRequest {
    const message = createBaseGetUserSessionsRequest();
    message.accessToken = object.accessToken ?? "";
    return message;
  },
};

function createBaseGetUserSessionsResponse(): GetUserSessionsResponse {
  return { sessions: [] };
}

export const GetUserSessionsResponse: MessageFns<GetUserSessionsResponse> = {
  encode(message: GetUserSessionsResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.sessions) {
      UserSession.encode(v!, writer.uint32(10).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): GetUserSessionsResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetUserSessionsResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.sessions.push(UserSession.decode(reader, reader.uint32()));
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GetUserSessionsResponse {
    return {
      sessions: globalThis.Array.isArray(object?.sessions)
        ? object.sessions.map((e: any) => UserSession.fromJSON(e))
        : [],
    };
  },

  toJSON(message: GetUserSessionsResponse): unknown {
    const obj: any = {};
    if (message.sessions?.length) {
      obj.sessions = message.sessions.map((e) => UserSession.toJSON(e));
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<GetUserSessionsResponse>, I>>(base?: I): GetUserSessionsResponse {
    return GetUserSessionsResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<GetUserSessionsResponse>, I>>(object: I): GetUserSessionsResponse {
    const message = createBaseGetUserSessionsResponse();
    message.sessions = object.sessions?.map((e) => UserSession.fromPartial(e)) || [];
    return message;
  },
};

function createBaseRevokeSessionRequest(): RevokeSessionRequest {
  return { accessToken: "", sessionId: "", reason: undefined };
}

export const RevokeSessionRequest: MessageFns<RevokeSessionRequest> = {
  encode(message: RevokeSessionRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.accessToken !== "") {
      writer.uint32(10).string(message.accessToken);
    }
    if (message.sessionId !== "") {
      writer.uint32(18).string(message.sessionId);
    }
    if (message.reason !== undefined) {
      writer.uint32(26).string(message.reason);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): RevokeSessionRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseRevokeSessionRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.accessToken = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.sessionId = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.reason = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): RevokeSessionRequest {
    return {
      accessToken: isSet(object.accessToken) ? globalThis.String(object.accessToken) : "",
      sessionId: isSet(object.sessionId) ? globalThis.String(object.sessionId) : "",
      reason: isSet(object.reason) ? globalThis.String(object.reason) : undefined,
    };
  },

  toJSON(message: RevokeSessionRequest): unknown {
    const obj: any = {};
    if (message.accessToken !== "") {
      obj.accessToken = message.accessToken;
    }
    if (message.sessionId !== "") {
      obj.sessionId = message.sessionId;
    }
    if (message.reason !== undefined) {
      obj.reason = message.reason;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<RevokeSessionRequest>, I>>(base?: I): RevokeSessionRequest {
    return RevokeSessionRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<RevokeSessionRequest>, I>>(object: I): RevokeSessionRequest {
    const message = createBaseRevokeSessionRequest();
    message.accessToken = object.accessToken ?? "";
    message.sessionId = object.sessionId ?? "";
    message.reason = object.reason ?? undefined;
    return message;
  },
};

function createBaseRevokeSessionResponse(): RevokeSessionResponse {
  return { success: false, message: "" };
}

export const RevokeSessionResponse: MessageFns<RevokeSessionResponse> = {
  encode(message: RevokeSessionResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.success !== false) {
      writer.uint32(8).bool(message.success);
    }
    if (message.message !== "") {
      writer.uint32(18).string(message.message);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): RevokeSessionResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseRevokeSessionResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.success = reader.bool();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.message = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): RevokeSessionResponse {
    return {
      success: isSet(object.success) ? globalThis.Boolean(object.success) : false,
      message: isSet(object.message) ? globalThis.String(object.message) : "",
    };
  },

  toJSON(message: RevokeSessionResponse): unknown {
    const obj: any = {};
    if (message.success !== false) {
      obj.success = message.success;
    }
    if (message.message !== "") {
      obj.message = message.message;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<RevokeSessionResponse>, I>>(base?: I): RevokeSessionResponse {
    return RevokeSessionResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<RevokeSessionResponse>, I>>(object: I): RevokeSessionResponse {
    const message = createBaseRevokeSessionResponse();
    message.success = object.success ?? false;
    message.message = object.message ?? "";
    return message;
  },
};

function createBaseUserProfile(): UserProfile {
  return {
    id: "",
    googleId: "",
    email: "",
    name: "",
    givenName: undefined,
    familyName: undefined,
    pictureUrl: undefined,
    locale: undefined,
    isActive: false,
    isVerified: false,
    createdAt: 0n,
    updatedAt: 0n,
    lastLoginAt: undefined,
    preferences: "",
  };
}

export const UserProfile: MessageFns<UserProfile> = {
  encode(message: UserProfile, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.id !== "") {
      writer.uint32(10).string(message.id);
    }
    if (message.googleId !== "") {
      writer.uint32(18).string(message.googleId);
    }
    if (message.email !== "") {
      writer.uint32(26).string(message.email);
    }
    if (message.name !== "") {
      writer.uint32(34).string(message.name);
    }
    if (message.givenName !== undefined) {
      writer.uint32(42).string(message.givenName);
    }
    if (message.familyName !== undefined) {
      writer.uint32(50).string(message.familyName);
    }
    if (message.pictureUrl !== undefined) {
      writer.uint32(58).string(message.pictureUrl);
    }
    if (message.locale !== undefined) {
      writer.uint32(66).string(message.locale);
    }
    if (message.isActive !== false) {
      writer.uint32(72).bool(message.isActive);
    }
    if (message.isVerified !== false) {
      writer.uint32(80).bool(message.isVerified);
    }
    if (message.createdAt !== 0n) {
      if (BigInt.asIntN(64, message.createdAt) !== message.createdAt) {
        throw new globalThis.Error("value provided for field message.createdAt of type int64 too large");
      }
      writer.uint32(88).int64(message.createdAt);
    }
    if (message.updatedAt !== 0n) {
      if (BigInt.asIntN(64, message.updatedAt) !== message.updatedAt) {
        throw new globalThis.Error("value provided for field message.updatedAt of type int64 too large");
      }
      writer.uint32(96).int64(message.updatedAt);
    }
    if (message.lastLoginAt !== undefined) {
      if (BigInt.asIntN(64, message.lastLoginAt) !== message.lastLoginAt) {
        throw new globalThis.Error("value provided for field message.lastLoginAt of type int64 too large");
      }
      writer.uint32(104).int64(message.lastLoginAt);
    }
    if (message.preferences !== "") {
      writer.uint32(114).string(message.preferences);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): UserProfile {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseUserProfile();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.id = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.googleId = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.email = reader.string();
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.name = reader.string();
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.givenName = reader.string();
          continue;
        }
        case 6: {
          if (tag !== 50) {
            break;
          }

          message.familyName = reader.string();
          continue;
        }
        case 7: {
          if (tag !== 58) {
            break;
          }

          message.pictureUrl = reader.string();
          continue;
        }
        case 8: {
          if (tag !== 66) {
            break;
          }

          message.locale = reader.string();
          continue;
        }
        case 9: {
          if (tag !== 72) {
            break;
          }

          message.isActive = reader.bool();
          continue;
        }
        case 10: {
          if (tag !== 80) {
            break;
          }

          message.isVerified = reader.bool();
          continue;
        }
        case 11: {
          if (tag !== 88) {
            break;
          }

          message.createdAt = reader.int64() as bigint;
          continue;
        }
        case 12: {
          if (tag !== 96) {
            break;
          }

          message.updatedAt = reader.int64() as bigint;
          continue;
        }
        case 13: {
          if (tag !== 104) {
            break;
          }

          message.lastLoginAt = reader.int64() as bigint;
          continue;
        }
        case 14: {
          if (tag !== 114) {
            break;
          }

          message.preferences = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): UserProfile {
    return {
      id: isSet(object.id) ? globalThis.String(object.id) : "",
      googleId: isSet(object.googleId) ? globalThis.String(object.googleId) : "",
      email: isSet(object.email) ? globalThis.String(object.email) : "",
      name: isSet(object.name) ? globalThis.String(object.name) : "",
      givenName: isSet(object.givenName) ? globalThis.String(object.givenName) : undefined,
      familyName: isSet(object.familyName) ? globalThis.String(object.familyName) : undefined,
      pictureUrl: isSet(object.pictureUrl) ? globalThis.String(object.pictureUrl) : undefined,
      locale: isSet(object.locale) ? globalThis.String(object.locale) : undefined,
      isActive: isSet(object.isActive) ? globalThis.Boolean(object.isActive) : false,
      isVerified: isSet(object.isVerified) ? globalThis.Boolean(object.isVerified) : false,
      createdAt: isSet(object.createdAt) ? BigInt(object.createdAt) : 0n,
      updatedAt: isSet(object.updatedAt) ? BigInt(object.updatedAt) : 0n,
      lastLoginAt: isSet(object.lastLoginAt) ? BigInt(object.lastLoginAt) : undefined,
      preferences: isSet(object.preferences) ? globalThis.String(object.preferences) : "",
    };
  },

  toJSON(message: UserProfile): unknown {
    const obj: any = {};
    if (message.id !== "") {
      obj.id = message.id;
    }
    if (message.googleId !== "") {
      obj.googleId = message.googleId;
    }
    if (message.email !== "") {
      obj.email = message.email;
    }
    if (message.name !== "") {
      obj.name = message.name;
    }
    if (message.givenName !== undefined) {
      obj.givenName = message.givenName;
    }
    if (message.familyName !== undefined) {
      obj.familyName = message.familyName;
    }
    if (message.pictureUrl !== undefined) {
      obj.pictureUrl = message.pictureUrl;
    }
    if (message.locale !== undefined) {
      obj.locale = message.locale;
    }
    if (message.isActive !== false) {
      obj.isActive = message.isActive;
    }
    if (message.isVerified !== false) {
      obj.isVerified = message.isVerified;
    }
    if (message.createdAt !== 0n) {
      obj.createdAt = message.createdAt.toString();
    }
    if (message.updatedAt !== 0n) {
      obj.updatedAt = message.updatedAt.toString();
    }
    if (message.lastLoginAt !== undefined) {
      obj.lastLoginAt = message.lastLoginAt.toString();
    }
    if (message.preferences !== "") {
      obj.preferences = message.preferences;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<UserProfile>, I>>(base?: I): UserProfile {
    return UserProfile.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<UserProfile>, I>>(object: I): UserProfile {
    const message = createBaseUserProfile();
    message.id = object.id ?? "";
    message.googleId = object.googleId ?? "";
    message.email = object.email ?? "";
    message.name = object.name ?? "";
    message.givenName = object.givenName ?? undefined;
    message.familyName = object.familyName ?? undefined;
    message.pictureUrl = object.pictureUrl ?? undefined;
    message.locale = object.locale ?? undefined;
    message.isActive = object.isActive ?? false;
    message.isVerified = object.isVerified ?? false;
    message.createdAt = object.createdAt ?? 0n;
    message.updatedAt = object.updatedAt ?? 0n;
    message.lastLoginAt = object.lastLoginAt ?? undefined;
    message.preferences = object.preferences ?? "";
    return message;
  },
};

function createBaseUserSession(): UserSession {
  return {
    id: "",
    deviceInfo: "",
    ipAddress: undefined,
    userAgent: undefined,
    createdAt: 0n,
    lastActivityAt: 0n,
    expiresAt: 0n,
    isCurrent: false,
  };
}

export const UserSession: MessageFns<UserSession> = {
  encode(message: UserSession, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.id !== "") {
      writer.uint32(10).string(message.id);
    }
    if (message.deviceInfo !== "") {
      writer.uint32(18).string(message.deviceInfo);
    }
    if (message.ipAddress !== undefined) {
      writer.uint32(26).string(message.ipAddress);
    }
    if (message.userAgent !== undefined) {
      writer.uint32(34).string(message.userAgent);
    }
    if (message.createdAt !== 0n) {
      if (BigInt.asIntN(64, message.createdAt) !== message.createdAt) {
        throw new globalThis.Error("value provided for field message.createdAt of type int64 too large");
      }
      writer.uint32(40).int64(message.createdAt);
    }
    if (message.lastActivityAt !== 0n) {
      if (BigInt.asIntN(64, message.lastActivityAt) !== message.lastActivityAt) {
        throw new globalThis.Error("value provided for field message.lastActivityAt of type int64 too large");
      }
      writer.uint32(48).int64(message.lastActivityAt);
    }
    if (message.expiresAt !== 0n) {
      if (BigInt.asIntN(64, message.expiresAt) !== message.expiresAt) {
        throw new globalThis.Error("value provided for field message.expiresAt of type int64 too large");
      }
      writer.uint32(56).int64(message.expiresAt);
    }
    if (message.isCurrent !== false) {
      writer.uint32(64).bool(message.isCurrent);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): UserSession {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseUserSession();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.id = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.deviceInfo = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.ipAddress = reader.string();
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.userAgent = reader.string();
          continue;
        }
        case 5: {
          if (tag !== 40) {
            break;
          }

          message.createdAt = reader.int64() as bigint;
          continue;
        }
        case 6: {
          if (tag !== 48) {
            break;
          }

          message.lastActivityAt = reader.int64() as bigint;
          continue;
        }
        case 7: {
          if (tag !== 56) {
            break;
          }

          message.expiresAt = reader.int64() as bigint;
          continue;
        }
        case 8: {
          if (tag !== 64) {
            break;
          }

          message.isCurrent = reader.bool();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): UserSession {
    return {
      id: isSet(object.id) ? globalThis.String(object.id) : "",
      deviceInfo: isSet(object.deviceInfo) ? globalThis.String(object.deviceInfo) : "",
      ipAddress: isSet(object.ipAddress) ? globalThis.String(object.ipAddress) : undefined,
      userAgent: isSet(object.userAgent) ? globalThis.String(object.userAgent) : undefined,
      createdAt: isSet(object.createdAt) ? BigInt(object.createdAt) : 0n,
      lastActivityAt: isSet(object.lastActivityAt) ? BigInt(object.lastActivityAt) : 0n,
      expiresAt: isSet(object.expiresAt) ? BigInt(object.expiresAt) : 0n,
      isCurrent: isSet(object.isCurrent) ? globalThis.Boolean(object.isCurrent) : false,
    };
  },

  toJSON(message: UserSession): unknown {
    const obj: any = {};
    if (message.id !== "") {
      obj.id = message.id;
    }
    if (message.deviceInfo !== "") {
      obj.deviceInfo = message.deviceInfo;
    }
    if (message.ipAddress !== undefined) {
      obj.ipAddress = message.ipAddress;
    }
    if (message.userAgent !== undefined) {
      obj.userAgent = message.userAgent;
    }
    if (message.createdAt !== 0n) {
      obj.createdAt = message.createdAt.toString();
    }
    if (message.lastActivityAt !== 0n) {
      obj.lastActivityAt = message.lastActivityAt.toString();
    }
    if (message.expiresAt !== 0n) {
      obj.expiresAt = message.expiresAt.toString();
    }
    if (message.isCurrent !== false) {
      obj.isCurrent = message.isCurrent;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<UserSession>, I>>(base?: I): UserSession {
    return UserSession.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<UserSession>, I>>(object: I): UserSession {
    const message = createBaseUserSession();
    message.id = object.id ?? "";
    message.deviceInfo = object.deviceInfo ?? "";
    message.ipAddress = object.ipAddress ?? undefined;
    message.userAgent = object.userAgent ?? undefined;
    message.createdAt = object.createdAt ?? 0n;
    message.lastActivityAt = object.lastActivityAt ?? 0n;
    message.expiresAt = object.expiresAt ?? 0n;
    message.isCurrent = object.isCurrent ?? false;
    return message;
  },
};

type Builtin = Date | Function | Uint8Array | string | number | boolean | bigint | undefined;

export type DeepPartial<T> = T extends Builtin ? T
  : T extends globalThis.Array<infer U> ? globalThis.Array<DeepPartial<U>>
  : T extends ReadonlyArray<infer U> ? ReadonlyArray<DeepPartial<U>>
  : T extends {} ? { [K in keyof T]?: DeepPartial<T[K]> }
  : Partial<T>;

type KeysOfUnion<T> = T extends T ? keyof T : never;
export type Exact<P, I extends P> = P extends Builtin ? P
  : P & { [K in keyof P]: Exact<P[K], I[K]> } & { [K in Exclude<keyof I, KeysOfUnion<P>>]: never };

function isSet(value: any): boolean {
  return value !== null && value !== undefined;
}

export interface MessageFns<T> {
  encode(message: T, writer?: BinaryWriter): BinaryWriter;
  decode(input: BinaryReader | Uint8Array, length?: number): T;
  fromJSON(object: any): T;
  toJSON(message: T): unknown;
  create<I extends Exact<DeepPartial<T>, I>>(base?: I): T;
  fromPartial<I extends Exact<DeepPartial<T>, I>>(object: I): T;
}
